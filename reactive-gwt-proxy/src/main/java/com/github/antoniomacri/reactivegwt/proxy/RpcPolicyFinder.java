/*
 * Copyright www.gdevelop.com.
 * Copyright Antonio Macr√¨
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.github.antoniomacri.reactivegwt.proxy;

import com.google.gwt.user.client.rpc.InvocationException;
import com.google.gwt.user.server.rpc.SerializationPolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.StringReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.ParseException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.regex.Pattern;
import java.util.stream.Collectors;


public class RpcPolicyFinder {
    private static final Logger log = LoggerFactory.getLogger(RpcPolicyFinder.class);
    private static final String GWT_PRC_POLICY_FILE_EXT = ".gwt.rpc";
    private static final Pattern PERMUTATION_NAME_PATTERN = Pattern.compile("'([A-Z0-9]){32}'");
    private static final Pattern CACHE_JS_FILE_PATTERN = Pattern.compile("([A-Z0-9]){32}\\.cache\\.js");
    private static final Pattern POLICY_NAME_DOUBLE_QUOTES_PATTERN = Pattern.compile("\"([A-Z0-9]){32}\"");
    private static final Pattern POLICY_NAME_SINGLE_QUOTES_PATTERN = Pattern.compile("'([A-Z0-9]){32}'");
    private static final Map<String, String> CACHE_POLICY_FILE = new ConcurrentHashMap<>();

    private final String moduleBaseURL;


    public RpcPolicyFinder(String moduleBaseURL) {
        this.moduleBaseURL = moduleBaseURL.trim();
    }

    public String getOrFetchPolicyName(String serviceName) {
        try {
            String policyName = fetchSerializationPolicyName(serviceName, moduleBaseURL);
            // TODO: save after fetching
            return policyName;
        } catch (Exception e) {
            throw new InvocationException("Error while fetching serialization policy name", e);
        }
    }

    public CompletionStage<String> getOrFetchPolicyNameAsync(String serviceName, ExecutorService executor) {
        // TODO: implement asyncrhonously on the given executor
        String policyName = getOrFetchPolicyName(serviceName);
        return CompletableFuture.completedFuture(policyName);
    }

    public SerializationPolicy getSerializationPolicy(String policyName) {
        String policyFileName = SerializationPolicyLoader.getSerializationPolicyFileName(policyName);
        String text = CACHE_POLICY_FILE.get(moduleBaseURL + policyFileName);
        if (text != null) {
            try {
                return SerializationPolicyLoader.load(new StringReader(text), null);
            } catch (IOException | ParseException e) {
                throw new InvocationException("Error while loading serialization policy " + policyName, e);
            }
        } else {
            throw new InvocationException("Error while loading serialization policy " + policyName);
        }
    }


    private String fetchSerializationPolicyName(String serviceName, String moduleBaseURL) {
        Map<String, String> policyMap = fetchSerializationPolicyMap(moduleBaseURL);
        return policyMap.get(serviceName);
    }


    /**
     * Map from ServiceInterface class name to Serialization Policy name.
     */
    private static Map<String, String> fetchSerializationPolicyMap(String moduleBaseURL) {
        Map<String, String> result = new HashMap<>();

        String[] urlparts = moduleBaseURL.split("/");
        String moduleNoCacheJs = urlparts[urlparts.length - 1] + ".nocache.js";
        String noCacheJsFileContent = getResposeText(moduleBaseURL + moduleNoCacheJs);

        PERMUTATION_NAME_PATTERN.matcher(noCacheJsFileContent).results().findFirst().map(matchResult -> {
            boolean xsiFrameLinker = noCacheJsFileContent.contains(".cache.js");
            if (xsiFrameLinker) {
                log.debug("Searching for policies generated by XSIFrame linker");
                String permutationFile = matchResult.group().replace("'", "") + ".cache.js";
                String responseText = getResposeText(moduleBaseURL + permutationFile);

                return POLICY_NAME_DOUBLE_QUOTES_PATTERN.matcher(responseText).results()
                        .map(mr -> mr.group().replace("\"", ""))
                        .collect(Collectors.toSet());
            } else {
                log.debug("Searching for policies generated by standard linker");
                String permutationFile = matchResult.group().replace("'", "") + ".cache.html";
                String responseText = getResposeText(moduleBaseURL + permutationFile);

                return POLICY_NAME_SINGLE_QUOTES_PATTERN.matcher(responseText).results()
                        .skip(1 /* the permutation name */)
                        .map(mr -> mr.group().replace("'", ""))
                        .collect(Collectors.toSet());
            }
        }).map(s -> s.isEmpty() ? null : s).orElseGet(() -> {
            // Examine the compilation-mappings.txt file that is generated by GWT, in the event
            // (such as in 2.7.0) that serialization policies are no longer in the nocache.js file
            log.info("No RemoteService fetched from server using JS/HTML fetcher, using JS fetcher...");
            String compilationMappings = getResposeText(moduleBaseURL + "compilation-mappings.txt");

            return CACHE_JS_FILE_PATTERN.matcher(compilationMappings).results().findFirst().map(matchResult -> {
                String browserSpec = matchResult.group();
                String cacheJs = getResposeText(moduleBaseURL + browserSpec);

                return POLICY_NAME_SINGLE_QUOTES_PATTERN.matcher(cacheJs).results()
                        .skip(1 /* the permutation name */)
                        .map(mr -> mr.group().replace("'", ""))
                        .collect(Collectors.toSet());
            }).orElseGet(Set::of);
        }).forEach(policyName -> {
            String policyContent = getResposeText(moduleBaseURL + policyName + GWT_PRC_POLICY_FILE_EXT);

            policyContent.lines().forEach(line -> {
                int pos = line.indexOf(", false, false, false, false, _, ");
                if (pos > 0) {
                    result.put(line.substring(0, pos), policyName);
                    result.put(line.substring(0, pos) + "Async", policyName);
                }
            });
        });

        if (result.isEmpty()) {
            log.info("No RemoteService fetched from server");
        } else {
            log.info("Found {} RemoteService(s): {}", result.size(), String.join(", ", result.keySet()));
        }
        return result;
    }

    private static String getResposeText(String fileUrl) {
        log.debug("Fetching file: {}", fileUrl);
        try {
            URL url = new URL(fileUrl);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();

            connection.setDoInput(true);
            connection.setDoOutput(true);
            connection.setInstanceFollowRedirects(true); // follow redirect
            connection.setRequestMethod("GET");
            connection.connect();

            String responseText = Utils.getResposeText(connection);

            if (fileUrl.endsWith(GWT_PRC_POLICY_FILE_EXT)) {
                CACHE_POLICY_FILE.put(fileUrl, responseText);
            }

            return responseText;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
