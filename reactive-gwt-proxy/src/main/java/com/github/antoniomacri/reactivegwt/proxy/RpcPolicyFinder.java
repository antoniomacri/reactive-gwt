/*
 * Copyright www.gdevelop.com.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.github.antoniomacri.reactivegwt.proxy;

import com.google.gwt.user.client.rpc.InvocationException;
import com.google.gwt.user.server.rpc.SerializationPolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.text.ParseException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RpcPolicyFinder {
    private static final Logger log = LoggerFactory.getLogger(RpcPolicyFinder.class);
    private static final Map<String, String> CACHE_POLICY_FILE = new ConcurrentHashMap<>();
    private static final String GWT_PRC_POLICY_FILE_EXT = ".gwt.rpc";

    private final String moduleBaseURL;


    public RpcPolicyFinder(String moduleBaseURL) {
        this.moduleBaseURL = moduleBaseURL.trim();
    }

    public String getOrFetchPolicyName(String serviceName) {
        try {
            String policyName = fetchSerializationPolicyName(serviceName, moduleBaseURL);
            // TODO: save after fetching
            return policyName;
        } catch (IOException e) {
            throw new InvocationException("Error while fetching serialization policy name", e);
        }
    }

    public SerializationPolicy getSerializationPolicy(String policyName) {
        String policyFileName = SerializationPolicyLoader.getSerializationPolicyFileName(policyName);
        String text = CACHE_POLICY_FILE.get(moduleBaseURL + policyFileName);
        if (text != null) {
            try {
                return SerializationPolicyLoader.load(new StringReader(text), null);
            } catch (IOException | ParseException e) {
                throw new InvocationException("Error while loading serialization policy " + policyName, e);
            }
        } else {
            throw new InvocationException("Error while loading serialization policy " + policyName);
        }
    }


    private String fetchSerializationPolicyName(String serviceName, String moduleBaseURL) throws IOException {
        Map<String, String> policyMap = fetchSerializationPolicyMap(moduleBaseURL);
        return policyMap.get(serviceName);
    }


    private static void dumpRemoteService(Map<String, String> result) {
        if (!result.isEmpty()) {
            log.debug("Found " + result.size() + " RemoteService(s) in the classpath");
            StringBuilder s = new StringBuilder();
            for (String className : result.keySet()) {
                s.append(className).append("\n");
            }
            log.debug(s.toString());
        } else {
            log.debug("No RemoteService in the result");
        }
    }

    /**
     * In the event (such as in 2.7.0) that serializationpolicy's are no longer
     * stated in the nocache.js file. This method examines the
     * compilation-mappings.txt file that is generated by GWT
     */
    private static Map<String, String> fetcherSerializationPolicyNameJS(String moduleBaseURL) throws IOException {
        Map<String, String> result = new HashMap<>();
        // get compilation-mappings.txt
        // match first cache.js
        // match all possible policy file names in the cache.js
        String moduleCompilationMappings = "compilation-mappings.txt";
        String responseText = getResposeText(moduleBaseURL + moduleCompilationMappings);
        // parse the compilation mappings for any browser cache.js
        // Permutation name is 32 chars surrounded by apostrophe
        String regex = "([A-Z0-9]){32}\\.cache\\.js";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(responseText);
        if (matcher.find()) {
            String browserSpec = matcher.group();
            responseText = getResposeText(moduleBaseURL + browserSpec);
            pattern = Pattern.compile("'([A-Z0-9]){32}'");
            matcher = pattern.matcher(responseText);
            int i = 0;
            while (matcher.find()) {
                String policyName = matcher.group();
                policyName = policyName.replace("'", "");
                if (0 == i++) {
                    // The first one is the permutation name
                    continue;
                }
                log.debug("Retrieving Policy File: {}{}{}", moduleBaseURL, policyName, GWT_PRC_POLICY_FILE_EXT);
                responseText = getResposeText(moduleBaseURL + policyName + GWT_PRC_POLICY_FILE_EXT);
                result.putAll(parsePolicyName(policyName, new ByteArrayInputStream(responseText.getBytes(StandardCharsets.UTF_8))));
            }
        }
        if (result.isEmpty()) {
            log.info("No RemoteService fetched from server using JS fetcher");
        } else {
            log.info("Remote Services found with JS Fetcher");
            dumpRemoteService(result);
        }

        return result;
    }

    /**
     * Map from ServiceInterface class name to Serialization Policy name.
     */
    private static Map<String, String> fetchSerializationPolicyMap(String moduleBaseURL) throws IOException {
        Map<String, String> result = new HashMap<>();

        moduleBaseURL = moduleBaseURL.trim(); // remove outer trim just in case
        String[] urlparts = moduleBaseURL.split("/");
        // get last word of url appended with .nocache.js
        String moduleNoCacheJs = urlparts[urlparts.length - 1] + ".nocache.js";
        log.debug("Fetching Serialization Policys from {}", moduleBaseURL + moduleNoCacheJs);
        String responseText = getResposeText(moduleBaseURL + moduleNoCacheJs);
        // parse the .nocache.js for list of Permutation name
        // Permutation name is 32 chars surrounded by apostrophe
        String regex = "'([A-Z0-9]){32}'";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(responseText);

        boolean xsiFrameLinker = responseText.contains(".cache.js");
        log.debug("XSIFrameLinker: {}", xsiFrameLinker);
        if (matcher.find()) {
            if (!xsiFrameLinker) {
                log.debug("Searching for policy's generated by standard linker");
                String permutationFile = matcher.group();
                permutationFile = permutationFile.replace("'", "");

                // Load the first permutation html file
                permutationFile += ".cache.html";
                log.trace("Accessing permutation file: {}", permutationFile);
                responseText = getResposeText(moduleBaseURL + permutationFile);
                matcher = pattern.matcher(responseText);
                int i = 0;
                while (matcher.find()) {
                    String policyName = matcher.group();
                    policyName = policyName.replace("'", "");
                    if (0 == i++) {
                        // The first one is the permutation name
                        continue;
                    }
                    log.trace("Accessing policy file: {}", policyName);
                    responseText = getResposeText(moduleBaseURL + policyName + GWT_PRC_POLICY_FILE_EXT);
                    result.putAll(parsePolicyName(policyName,
                            new ByteArrayInputStream(responseText.getBytes(StandardCharsets.UTF_8))));
                }
            } else {
                log.debug("Searching for policy's generated by XSIFrame linker");
                String permutationFile = matcher.group();
                permutationFile = permutationFile.replace("'", "");

                // Load the first permutation js file
                permutationFile += ".cache.js";
                log.trace("Accessing permutation file: {}", permutationFile);
                responseText = getResposeText(moduleBaseURL + permutationFile);

                String rpcRegex = "\"([A-Z0-9]){32}\"";
                Pattern rpcPattern = Pattern.compile(rpcRegex);

                matcher = rpcPattern.matcher(responseText);
                while (matcher.find()) {
                    String policyName = matcher.group();
                    policyName = policyName.replace("\"", "");
                    log.trace("Accessing policy file: {}", policyName);
                    responseText = getResposeText(moduleBaseURL + policyName + GWT_PRC_POLICY_FILE_EXT);
                    result.putAll(parsePolicyName(policyName,
                            new ByteArrayInputStream(responseText.getBytes(StandardCharsets.UTF_8))));
                }
            }
        }

        if (result.isEmpty()) {
            log.info("No RemoteService fetched from server using JS/HTML fetcher");
            result = fetcherSerializationPolicyNameJS(moduleBaseURL);
        } else {
            log.info("Found RemoteServices with JS/HTML Fetcher");
            dumpRemoteService(result);
        }
        return result;
    }

    private static String getResposeText(String myurl) throws IOException {
        URL url = new URL(myurl);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();

        connection.setDoInput(true);
        connection.setDoOutput(true);
        connection.setInstanceFollowRedirects(true); // follow redirect
        connection.setRequestMethod("GET");
        connection.connect();

        String responseText = Utils.getResposeText(connection);

        if (myurl.endsWith(GWT_PRC_POLICY_FILE_EXT)) {
            CACHE_POLICY_FILE.put(myurl, responseText);
        }

        return responseText;
    }

    private static Map<String, String> parsePolicyName(String policyName, InputStream in) throws IOException {
        Map<String, String> result = new HashMap<>();

        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        String line = reader.readLine();
        while (line != null) {
            int pos = line.indexOf(", false, false, false, false, _, ");
            if (pos > 0) {
                result.put(line.substring(0, pos), policyName);
                result.put(line.substring(0, pos) + "Async", policyName);
            }
            line = reader.readLine();
        }

        return result;
    }
}